# Reactor

本项目是一个基于 Reactor 模式的 LinuxC++ 网络服务器框架，支持多线程 TCP 服务器，单线程 TCP 服务器，可以让开发者专注于业务，快速开发出一个高效的服务器应用

## 概览

![overview]()

## 反应堆模型

可以通过这个反应堆检测事件，检测完这个事件之后，可以把相应的事件进行一系列的处理，这就是一个反应堆模型

### Listener

监听器，这里有用于监听的端口和用于监听的文件描述符

### Channel

通道，将用于监听和通信的文件描述符进行封装，对应的就是一个通道，一个服务器需要接受客户端的连接需要一个文件描述符，所有的客户端发送的连接都需要通过这个文件描述符进行连接，每个客户端都对应一个文件描述符

封装这个 Channel 需要一个文件描述符 fd，可以是通信的也可以是监听的，不管是通信的还是监听的描述符，最终都要放到 I/O 多路复用模型里面进行检测，还需要封装这个文件描述符需要检测的事件：r、w、rw

这个模块主要有以下函数：

1. 初始化一个 Channel
2. 修改 fd 的事件（检测 or 不检测）
    - 这里用到了 C 语言的通用属性做法，通过标志位来判断是否检测
    - 当要增加这个检测就对`WRITE_EVENT`进行按位或，不检测就是先对`WRITE_EVENT`取反再按位与
3. 判断是否需要检测文件描述符的写事件

### ChannelMap

里面存储的就是一个对应关系，每个文件描述符都对应一个 Channel，基于一个文件描述符就可以找到对应的 Channel 的实例

### Dispatcher

I/O 多路复用的模型，这里有三种模型可以选择：epoll、poll、select，这三个是三选一，不是同时使用，通过 Dispatcher 检测是一些系列的事件，将对应的事件注册到了反应堆，当有时间发生之后，就会调用相关的处理动作：回调函数

### EventLoop

事件循环，当服务器启动之后，会有不停的事件触发，事件包括：客户端的新连接、已经建立连接的客户端和服务器之间的通信

可以通过这个向 Dispatcher 进行添加事件，就是事件对应的文件描述符原来不在 Dispatcher 上，把文件描述符添加到了这个上面，待检测的节点就多了一个；还有就是 Dispatcher 上的节点已经和客户端断开了连接，就不需要再次对他进行检测了，因此就需要将这个节点从 Dispatcher 上删除

## 多线程

这里用到了 ThreadPool，先使用单个 Thread 的模型，再基于单个 Thread 的模型去编写一个 ThreadPool

### WorkerThread

### ThreadPool

## I/O模型

本模块涉及数据的读写操作，读写数据都是需要一块内存，例如：read 数据需要一块内存，将对端发送过来的数据放到内存里面，再将内存中的数据读取出来进行一些列的后续处理，这一块数据其实就是 Http 请求消息；当要发送数据首先需要一块内存，组织一个数据块就是 Http 响应消息，将数据写到这块内存里面，然后通过 write 发送到对端，将读数据和写数据封装成了一个 Buffer

在本项目中，在 Tcp 通信中，有用于监听的文件描述符还有用于通信的文件描述符，在 TcpConnection 里面封装了用于通信的文件描述符，基于这个文件描述符就可以接受数据和发送数据了

### Buffer

### TcpConnection

## 服务器

### TcpServer

### HttpServer

## Http

这个模块是用来解析客户端发送来的数据和发送服务端的数据，将请求行和请求头解析出来的数据保存起来，然后基于这些数据去组织 Http 响应，就是组织回复的数据

### HttpRequest

### HttpResponse

